SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

SET NOCOUNT ON
GO

SET XACT_ABORT ON
GO

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
GO

BEGIN TRANSACTION
GO

-- Add DOCUMENT_ID back to [dops].[ORBC_DOCUMENT_TEMPLATE]
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE] ADD DOCUMENT_ID [varchar](50);

-- Populate [dops].[ORBC_DOCUMENT_TEMPLATE].[DOCUMENT_ID]
IF @@ERROR <> 0 SET NOEXEC ON
GO
UPDATE [dops].[ORBC_DOCUMENT_TEMPLATE] SET DOCUMENT_ID = (SELECT ID FROM [dops].[ORBC_DOCUMENT] WHERE FILE_NAME = [dops].[ORBC_DOCUMENT_TEMPLATE].FILE_NAME)

-- Change [dops].[ORBC_DOCUMENT_TEMPLATE].[DOCUMENT_ID] to non-nullable
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE] ALTER COLUMN DOCUMENT_ID VARCHAR(50) NOT NULL;


-- Alter trigger dops.ORBC_DOCTMP_A_S_IUD_TR - Add DOCUMENT_ID and remove IS_ACTIVE and FILE_NAME
PRINT N'Alter trigger dops.ORBC_DOCTMP_A_S_IUD_TR'
GO
ALTER TRIGGER [dops].[ORBC_DOCTMP_A_S_IUD_TR] ON dops.[ORBC_DOCUMENT_TEMPLATE] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] set END_DATE_HIST = @curr_date where TEMPLATE_ID in (select TEMPLATE_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] ([TEMPLATE_ID], [TEMPLATE_NAME], [TEMPLATE_VERSION], [DOCUMENT_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _DOCUMENT_TEMPLATE_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [TEMPLATE_ID], [TEMPLATE_NAME], [TEMPLATE_VERSION], [DOCUMENT_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dops].[ORBC_DOCUMENT_TEMPLATE_H_ID_SEQ]) as [_DOCUMENT_TEMPLATE_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- drop CONSTRAINT DF_ORBC_DOCUMENT_TEMPLATE_IS_ACTIVE
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE]
DROP CONSTRAINT DF_ORBC_DOCUMENT_TEMPLATE_IS_ACTIVE;

-- drop column [dops].[ORBC_DOCUMENT_TEMPLATE].[IS_ACTIVE]
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE] DROP COLUMN IS_ACTIVE;

-- drop column [dops].[ORBC_DOCUMENT_TEMPLATE].[FILE_NAME]
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE] DROP COLUMN FILE_NAME;

IF @@ERROR <> 0
	SET NOEXEC ON
GO

DECLARE @VersionDescription VARCHAR(255)

SET @VersionDescription = 'Remove IS_ACTIVE and FILE_NAME from dops.ORBC_DOCUMENT_TEMPLATE and add document_id'

INSERT [dbo].[ORBC_SYS_VERSION] (
	[VERSION_ID]
	,[DESCRIPTION]
	,[RELEASE_DATE]
	)
VALUES (
	73
	,@VersionDescription
	,getutcdate()
	)
GO

IF @@ERROR <> 0
	SET NOEXEC ON
GO

COMMIT TRANSACTION
GO

IF @@ERROR <> 0
	SET NOEXEC ON
GO

DECLARE @Success AS BIT

SET @Success = 1
SET NOEXEC OFF

IF (@Success = 1)
	PRINT 'The database revert succeeded'
ELSE
BEGIN
	IF @@TRANCOUNT > 0
		ROLLBACK TRANSACTION

	PRINT 'The database revert failed'
END
GO