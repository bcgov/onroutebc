SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET NOCOUNT ON
GO

SET XACT_ABORT ON
GO
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
GO
BEGIN TRANSACTION
GO

-- Add mon-nullable column [dops].[ORBC_DOCUMENT_TEMPLATE].[IS_ACTIVE] with default 'N'
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE] ADD IS_ACTIVE CHAR(1) CONSTRAINT DF_ORBC_DOCUMENT_TEMPLATE_IS_ACTIVE DEFAULT('N') NOT NULL;

IF @@ERROR <> 0 SET NOEXEC ON
GO
-- The IS_ACTIVE column is not removed from the HIST table in
-- the revert script to avoid data loss, so it is only added here
-- if it does not already exist.
IF COL_LENGTH('dops.ORBC_DOCUMENT_TEMPLATE_HIST', 'IS_ACTIVE') IS NULL
BEGIN
	ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] ADD IS_ACTIVE CHAR(1) NULL;
END
GO

IF @@ERROR <> 0 SET NOEXEC ON
GO
EXEC sys.sp_addextendedproperty @name = N'MS_Description'
	,@value = N'Whether the template is currently active in onRouteBC - Y indicates yes, N indicates no'
	,@level0type = N'SCHEMA'
	,@level0name = N'dops'
	,@level1type = N'TABLE'
	,@level1Name = N'ORBC_DOCUMENT_TEMPLATE'
	,@level2type = N'COLUMN'
	,@level2name = N'IS_ACTIVE';

-- Set the IS_ACTIVE flag to Y for relevant records
IF @@ERROR <> 0 SET NOEXEC ON
GO
WITH LatestVersions
AS (
	SELECT TEMPLATE_ID
		,TEMPLATE_NAME
		,TEMPLATE_VERSION
		,ROW_NUMBER() OVER (
			PARTITION BY TEMPLATE_NAME ORDER BY TEMPLATE_VERSION DESC
			) AS rn
	FROM [dops].[ORBC_DOCUMENT_TEMPLATE]
	WHERE TEMPLATE_NAME NOT IN (
			'PERMIT'
			,'PERMIT_VOID'
			,'PERMIT_REVOKED'
			,'PERMIT_NRQCL'
			,'PERMIT_NRQCL_VOID'
			,'PERMIT_NRQCL_REVOKED'
			,'PERMIT_NRSCL'
			,'PERMIT_NRSCL_VOID'
			,'PERMIT_NRSCL_REVOKED'
			)
	)
UPDATE t
SET IS_ACTIVE = 'Y'
FROM [dops].[ORBC_DOCUMENT_TEMPLATE] t
INNER JOIN LatestVersions lv ON t.TEMPLATE_ID = lv.TEMPLATE_ID
	AND t.TEMPLATE_NAME = lv.TEMPLATE_NAME
	AND t.TEMPLATE_VERSION = lv.TEMPLATE_VERSION
WHERE lv.rn = 1;

-- Add FILE_NAME col in ORBC_DOCUMENT_TEMPLATE_HIST with values from dops.ORBC_DOCUMENT.FILE_NAME
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE] ADD FILE_NAME VARCHAR(50);

IF @@ERROR <> 0 SET NOEXEC ON
GO
-- The FILE_NAME column is not removed from the HIST table in
-- the revert script to avoid data loss, so it is only added here
-- if it does not already exist.
IF COL_LENGTH('dops.ORBC_DOCUMENT_TEMPLATE_HIST', 'FILE_NAME') IS NULL
BEGIN
	ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] ADD FILE_NAME VARCHAR(50) NULL;
END
GO

IF @@ERROR <> 0 SET NOEXEC ON
GO
EXEC sys.sp_addextendedproperty @name = N'MS_Description'
	,@value = N'The template file name in S3'
	,@level0type = N'SCHEMA'
	,@level0name = N'dops'
	,@level1type = N'TABLE'
	,@level1Name = N'ORBC_DOCUMENT_TEMPLATE'
	,@level2type = N'COLUMN'
	,@level2name = N'FILE_NAME';

-- Update the FILE_NAME col in ORBC_DOCUMENT_TEMPLATE with values from dops.ORBC_DOCUMENT.FILE_NAME
IF @@ERROR <> 0 SET NOEXEC ON
GO
UPDATE [dops].[ORBC_DOCUMENT_TEMPLATE]
SET FILE_NAME = (
		SELECT FILE_NAME
		FROM [dops].[ORBC_DOCUMENT] od
		WHERE od.ID = DOCUMENT_ID
		);

-- Update the FILE_NAME col in ORBC_DOCUMENT_TEMPLATE to non-nullable post data patch up
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE] ALTER COLUMN FILE_NAME VARCHAR(50) NOT NULL;

-- Drop column [dops].[ORBC_DOCUMENT_TEMPLATE].[IS_ACTIVE]
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE] DROP COLUMN DOCUMENT_ID;

-- Update the document_id col in ORBC_DOCUMENT_TEMPLATE_HIST to Nullable
IF @@ERROR <> 0 SET NOEXEC ON
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] ALTER COLUMN DOCUMENT_ID VARCHAR(50) NULL;

IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Alter trigger dops.ORBC_DOCTMP_A_S_IUD_TR. Remove DOCUMENT_ID and add IS_ACTIVE and FILE_NAME
PRINT N'Alter trigger dops.ORBC_DOCTMP_A_S_IUD_TR'
GO
ALTER TRIGGER [dops].[ORBC_DOCTMP_A_S_IUD_TR] ON dops.[ORBC_DOCUMENT_TEMPLATE] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] set END_DATE_HIST = @curr_date where TEMPLATE_ID in (select TEMPLATE_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] ([TEMPLATE_ID], [IS_ACTIVE], [FILE_NAME], [TEMPLATE_NAME], [TEMPLATE_VERSION], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _DOCUMENT_TEMPLATE_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [TEMPLATE_ID], [IS_ACTIVE], [FILE_NAME], [TEMPLATE_NAME], [TEMPLATE_VERSION], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dops].[ORBC_DOCUMENT_TEMPLATE_H_ID_SEQ]) as [_DOCUMENT_TEMPLATE_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO

IF @@ERROR <> 0 SET NOEXEC ON
GO


DECLARE @VersionDescription VARCHAR(255)
SET @VersionDescription = 'Add IS_ACTIVE and FILE_NAME to dops.ORBC_DOCUMENT_TEMPLATE and drop col DOCUMENT_ID'

INSERT [dbo].[ORBC_SYS_VERSION] ([VERSION_ID], [DESCRIPTION], [UPDATE_SCRIPT], [REVERT_SCRIPT], [RELEASE_DATE]) VALUES (74, @VersionDescription, '$(UPDATE_SCRIPT)', '$(REVERT_SCRIPT)', getutcdate())
IF @@ERROR <> 0 SET NOEXEC ON
GO

COMMIT TRANSACTION
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DECLARE @Success AS BIT
SET @Success = 1
SET NOEXEC OFF
IF (@Success = 1) PRINT 'The database update succeeded'
ELSE BEGIN
   IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION
   PRINT 'The database update failed'
END
GO
